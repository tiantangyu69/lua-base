--[[
模式匹配对于字符串操纵来说是强大的工具，你可能只需要简单的调用string.gsub和find就可以完成复杂的操作，然而，因为它功能强大你必须谨慎的使用它，否则会带来意想不到的结果。
对正常的解析器而言，模式匹配不是一个替代品。对于一个quick-and-dirty程序，你可以在源代码上进行一些有用的操作，但很难完成一个高质量的产品。前面提到的匹配C程序中注释的模
式是个很好的例子：'/%*.-%*/'。如果你的程序有一个字符串包含了"/*"，最终你将得到错误的结果：
--]]
test = [[char s[] = "a /* here";  /* a tricky string */]]
print(string.gsub(test, "/%*.-%*/", "<COMMENT>"))    --> char s[] = "a <COMMENT>

--[[
虽然这样内容的字符串很罕见，如果是你自己使用的话上面的模式可能还凑活。但你不能将一个带有这种毛病的程序作为产品出售。
一般情况下，Lua中的模式匹配效率是不错的：一个奔腾333MHz机器在一个有200K字符的文本内匹配所有的单词(30K的单词)只需要1/10秒。
但是你不能掉以轻心，应该一直对不同的情况特殊对待，尽可能的更明确的模式描述。一个限制宽松的模式比限制严格的模式可能慢很多。
一个极端的例子是模式 '(.-)%$' 用来获取一个字符串内$符号以前所有的字符，如果目标串中存在$符号，没有什么问题；但是如果目
标串中不存在$符号。上面的算法会首先从目标串的第一个字符开始进行匹配，遍历整个字符串之后没有找到$符号，然后从目标串的第
二个字符开始进行匹配，……这将花费原来平方次幂的时间，导致在一个奔腾333MHz的机器中需要3个多小时来处理一个200K的文本串。
可以使用下面这个模式避免上面的问题 '^(.-)%$'。定位符^告诉算法如果在第一个位置没有没找到匹配的子串就停止查找。使用这个定位符之后，同样的环境也只需要不到1/10秒的时间。
也需要小心空模式：匹配空串的模式。比如，如果你打算用模式 '%a*' 匹配名字，你会发现到处都是名字：
--]]
i, j = string.find(";$%  **#$hello13", "%a*")
print(i,j)    --> 1  0

--[[
这个例子中调用string.find正确的在目标串的开始处匹配了空字符。永远不要写一个以 '-' 开头或者结尾的模式，因为它将匹配空串。
这个修饰符得周围总是需要一些东西来定位他的扩展。相似的，一个包含 '.*' 的模式是一个需要注意的，因为这个结构可能会比你预算的扩展的要多。
有时候，使用Lua本身构造模式是很有用的。看一个例子，我们查找一个文本中行字符大于70个的行，也就是匹配一个非换行符之前有70个字符的行。
我们使用字符类'[^\n]'表示非换行符的字符。所以，我们可以使用这样一个模式来满足我们的需要：重复匹配单个字符的模式70次，后面跟着一个
匹配一个字符0次或多次的模式。我们不手工来写这个最终的模式，而使用函数string.rep：
--]]
pattern = string.rep("[^\n]", 70) .. "[^\n]*"

-- 另一个例子，假如你想进行一个大小写无关的查找。方法之一是将任何一个字符x变为字符类 '[xX]'。我们也可以使用一个函数进行自动转换：
function nocase (s)
    s = string.gsub(s, "%a", function (c)
       return string.format("[%s%s]", string.lower(c), string.upper(c))
    end)
    return s
end
print(nocase("Hi there!")) -->  [hH][iI] [tT][hH][eE][rR][eE]!

-- 有时候你可能想要将字符串s1转化为s2，而不关心其中的特殊字符。如果字符串s1和s2都是字符串序列，你可以给其中的特殊字符加上转义字符来实现。但是如果这些字符串是变量呢，你可以使用gsub来完成这种转义：
-- s1 = string.gsub(s1, "(%W)", "%%%1")
-- s2 = string.gsub(s2, "%%", "%%%%")
