--[[
前面我们看到的迭代器有一个缺点：每次调用都需要创建一个闭包，大多数情况下这种做法都没什么问题，例如在allwords迭代器中创建一个闭包的代价比起读整个文件来说微不足道，
然而在有些情况下创建闭包的代价是不能忍受的。在这些情况下我们可以使用范性for本身来保存迭代的状态。
前面我们看到在循环过程中范性for在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。下面详细说明。
范性for的文法如下：

for <var-list> in <exp-list> do
    <body>
end
--]]

-- <var-list>是以一个或多个逗号分隔的变量名列表，<exp-list>是以一个或多个逗号分隔的表达式列表，通常情况下exp-list只有一个值：迭代工厂的调用。
t = {"a", "b", "c", "d", "e"}
for k, v in pairs(t) do
    print(k, v)
end

--[[
上面代码中，k, v为变量列表；pair(t)为表达式列表。
在很多情况下变量列表也只有一个变量，比如：


for line in io.lines() do
    io.write(line, '\n')
end
--]]

--[[
我们称变量列表中第一个变量为控制变量，其值为nil时循环结束。
下面我们看看范性for的执行过程：
首先，初始化，计算in后面表达式的值，表达式应该返回范性for需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。
第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。
第三，将迭代函数返回的值赋给变量列表。
第四，如果返回的第一个值为nil循环结束，否则执行循环体。
第五，回到第二步再次调用迭代函数。
更具体地说：

for var_1, ..., var_n in explist do block end
等价于
do
    local _f, _s, _var = explist
    while true do
       local var_1, ... , var_n = _f(_s, _var)
       _var = var_1
       if _var == nil then break end
       block
    end
end

如果我们的迭代函数是f，状态常量是s，控制变量的初始值是a0，那么控制变量将循环：a1=f(s,a0)、a2=f(s,a1)、……，直到ai=nil。
--]]