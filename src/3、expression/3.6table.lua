-- 构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:
days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

-- Lua将"Sunday"初始化days[1]（第一个元素索引为1），用"Monday"初始化days[2]...
print(days[4])       --> Wednesday

-- 构造函数可以使用任何表达式初始化：
function sin(x)
	return x
end
	
tab = {sin(1), sin(2), sin(3), sin(4), sin(5),sin(6), sin(7), sin(8)}
print(tab)

-- 如果想初始化一个表作为record使用可以这样：
a = {x=1, y=3}       -->       a = {}; a.x=0; a.y=0
print(a.x)

-- 不管用何种方式创建table，我们都可以向表中添加或者删除任何类型的域，构造函数仅仅影响表的初始化。
w = {x=0, y=0, label="console"}
x = {sin(0), sin(1), sin(2)}
w[1] = "another field"
x.f = w
print(w["x"])     --> 0
print(w[1])       --> another field
print(x.f[1])     --> another field
w.x = nil         -- remove field "x"


-- 在同一个构造函数中可以混合列表风格和record风格进行初始化，如：
polyline = {color="blue", thickness=2, npoints=4,
              {x=0,   y=0},
              {x=-10, y=0},
              {x=-10, y=1},
              {x=0,   y=1}
}
-- 这个例子也表明我们可以嵌套构造函数来表示复杂的数据结构.
print(polyline[2].x)     --> -10


-- 每次调用构造函数，Lua都会创建一个新的table，可以使用table构造一个list：
--[[
list = nil
for line in io.lines() do
    list = {next=list, value=line}
end
--]]
-- 这段代码从标准输入读进每行，然后反序形成链表。下面的代码打印链表的内容：

-- 上面两种构造函数的初始化方式还有限制，比如你不能使用负索引初始化一个表中元素，字符串索引也不能被恰当的表示。下面介绍一种更一般的初始化方式，我们用[expression]显示的表示将被初始化的索引：
opnames = {["+"] = "add", ["-"] = "sub",
              ["*"] = "mul", ["/"] = "div"}
 
i = 20; s = "-"
a = {[i+0] = s, [i+1] = s..s, [i+2] = s..s..s}
 
print(opnames[s])    --> sub
print(a[22])         --> ---

-- list风格初始化和record风格初始化是这种一般初始化的特例:
a = {x=0, y=0}        -->       {["x"]=0, ["y"]=0}
a = {"red", "green", "blue"}        --> {[1]="red", [2]="green", [3]="blue"}

-- 如果真的想要数组下标从0开始：
days = {[0]="Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

-- 注意：不推荐数组下标从0开始，否则很多标准库不能使用。
-- 在构造函数的最后的","是可选的，可以方便以后的扩展。
a = {[1]="red", [2]="green", [3]="blue",}

-- 在构造函数中域分隔符逗号（","）可以用分号（";"）替代，通常我们使用分号用来分割不同类型的表元素。
a = {x=10, y=45; "one", "two", "three"}
print(a[1])

